import axios from 'axios';
import { Message, ThreadChannel } from 'discord.js';
import * as dotenv from 'dotenv';

dotenv.config();

interface GitHubConfig {
    enabled: boolean;
}

interface GitHubIssue {
    number: number;
    title: string;
    body: string;
    state: 'open' | 'closed';
    html_url: string;
}

interface GitHubComment {
    id: number;
    body: string;
    html_url: string;
}

export class GitHubSyncService {
    private config: GitHubConfig;
    private baseUrl = 'https://api.github.com';
    private issueMap: Map<string, number> = new Map(); // threadId -> issueNumber
    private commentMap: Map<string, number> = new Map(); // messageId -> commentId
    private token: string;
    private repository: string;
    private currentUser: string | null = null;
    private webhookCallback: ((issueNumber: number, threadId: string) => void) | null = null;

    constructor(config: GitHubConfig) {
        this.config = config;
        this.token = process.env.GITHUB_TOKEN || '';
        this.repository = process.env.GITHUB_REPOSITORY || '';
        
        if (config.enabled && (!this.token || !this.repository)) {
            console.warn('⚠️ GitHub 동기화가 활성화되었지만 GITHUB_TOKEN 또는 GITHUB_REPOSITORY 환경변수가 설정되지 않았습니다.');
            this.config.enabled = false;
        }
    }

    public setEnabled(enabled: boolean) {
        this.config.enabled = enabled;
    }

    public setWebhookCallback(callback: (issueNumber: number, threadId: string) => void) {
        this.webhookCallback = callback;
    }

    private getHeaders() {
        return {
            'Authorization': `token ${this.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'Discord-Forum-Bot'
        };
    }

    public async deleteCommentForMessage(messageId: string): Promise<boolean> {
        if (!this.config.enabled) {
            console.log('📤 GitHub 동기화가 비활성화되어 있습니다.');
            return false;
        }

        try {
            const commentId = this.commentMap.get(messageId);
            
            if (!commentId) {
                console.log(`⚠️ 메시지 ${messageId}에 해당하는 GitHub 댓글을 찾을 수 없습니다.`);
                return false;
            }

            console.log(`🐙 [GITHUB DEBUG] 댓글 삭제 시도: 댓글 ID ${commentId}`);

            const response = await axios.delete(
                `${this.baseUrl}/repos/${this.repository}/issues/comments/${commentId}`,
                { headers: this.getHeaders() }
            );

            if (response.status === 204) {
                // 성공적으로 삭제된 경우 매핑에서 제거
                this.commentMap.delete(messageId);
                console.log(`✅ [GITHUB DEBUG] 댓글 삭제 성공 및 매핑 제거: 메시지 ${messageId} -> 댓글 ${commentId}`);
                return true;
            } else {
                console.error(`❌ [GITHUB DEBUG] 댓글 삭제 실패: HTTP ${response.status}`);
                return false;
            }
        } catch (error: any) {
            if (error.response?.status === 404) {
                // 댓글이 이미 삭제된 경우 매핑에서 제거
                this.commentMap.delete(messageId);
                console.log(`⚠️ [GITHUB DEBUG] 댓글이 이미 삭제됨: 매핑 제거 ${messageId}`);
                return true;
            }
            console.error('❌ [GITHUB DEBUG] 댓글 삭제 중 오류:', error.response?.data || error.message);
            return false;
        }
    }

    public async createIssueForNewPost(message: Message, forumChannelName: string): Promise<string | null> {
        if (!this.config.enabled) {
            console.log('📤 GitHub 동기화가 비활성화되어 있습니다.');
            return null;
        }

        try {
            if (!message.guild || !message.channel) {
                console.log('❌ 길드 또는 채널 정보가 없습니다.');
                return null;
            }

            const thread = message.channel as ThreadChannel;
            const postLink = `https://discord.com/channels/${message.guild.id}/${thread.id}`;
            
            // Issue 제목과 본문 구성
            const title = `${thread.name}`;
            const body = `**${message.author.displayName || message.author.username}**
${message.content}

---
**Discord Forum:** ${forumChannelName}
**Source:** ${postLink}
**Thread ID:** ${thread.id}
*This issue is automatically synchronized with a corresponding thread in Discord.*`;

            // GitHub Issue 생성
            const response = await axios.post(
                `${this.baseUrl}/repos/${this.repository}/issues`,
                {
                    title,
                    body,
                    labels: ['discord-forum', 'new-post', forumChannelName.toLowerCase()]
                },
                { headers: this.getHeaders() }
            );

            const issue: GitHubIssue = response.data;
            
            // 스레드 ID와 이슈 번호 매핑 저장
            this.issueMap.set(thread.id, issue.number);
            
            // 웹훅 서비스에 매핑 정보 전달
            if (this.webhookCallback) {
                this.webhookCallback(issue.number, thread.id);
            }
            
            console.log(`✅ GitHub 이슈 생성 완료: #${issue.number} - ${issue.html_url}`);
            return issue.html_url;

        } catch (error: any) {
            console.error('❌ GitHub 이슈 생성 중 오류:', error.response?.data || error.message);
            return null;
        }
    }

    public async addCommentForNewMessage(message: Message, forumChannelName: string): Promise<string | null> {
        if (!this.config.enabled) {
            console.log('📤 GitHub 동기화가 비활성화되어 있습니다.');
            return null;
        }

        try {
            if (!message.guild || !message.channel) {
                console.log('❌ 길드 또는 채널 정보가 없습니다.');
                return null;
            }

            const thread = message.channel as ThreadChannel;
            let issueNumber = this.issueMap.get(thread.id);
            
            // 메모리에 이슈 번호가 없으면 GitHub에서 검색
            if (!issueNumber) {
                console.log(`🔍 스레드 ${thread.id}에 해당하는 GitHub 이슈를 검색 중...`);
                issueNumber = await this.findExistingIssue(thread.id, thread.name) ?? undefined;
                
                if (!issueNumber) {
                    console.log(`❌ 스레드 "${thread.name}"에 해당하는 GitHub 이슈를 찾을 수 없습니다.`);
                    return null;
                }
                
                // 찾은 이슈를 메모리에 저장
                this.issueMap.set(thread.id, issueNumber);
                console.log(`✅ 기존 GitHub 이슈 찾음: #${issueNumber}`);
            }

            const messageLink = `https://discord.com/channels/${message.guild.id}/${thread.id}/${message.id}`;
            
            // 댓글 본문 구성
            const commentBody = `**${message.author.displayName || message.author.username}**
${message.content}

---
**Discord Forum:** ${forumChannelName}
**Source:** ${messageLink}
* This issue is automatically synchronized with a corresponding thread in Discord.*`;

            // GitHub Comment 생성
            const response = await axios.post(
                `${this.baseUrl}/repos/${this.repository}/issues/${issueNumber}/comments`,
                { body: commentBody },
                { headers: this.getHeaders() }
            );

            const comment: GitHubComment = response.data;
            
            // 메시지 ID와 댓글 ID 매핑 저장
            this.commentMap.set(message.id, comment.id);
            console.log(`📝 [GITHUB DEBUG] 댓글 매핑 저장: 메시지 ${message.id} -> 댓글 ${comment.id}`);
            
            console.log(`✅ GitHub 댓글 추가 완료: ${comment.html_url}`);
            return comment.html_url;

        } catch (error: any) {
            console.error('❌ GitHub 댓글 추가 중 오류:', error.response?.data || error.message);
            return null;
        }
    }

    public async closeIssueForClosedPost(threadId: string, reason?: string): Promise<boolean> {
        if (!this.config.enabled) {
            console.log('📤 GitHub 동기화가 비활성화되어 있습니다.');
            return false;
        }

        try {
            let issueNumber = this.issueMap.get(threadId);
            
            if (!issueNumber) {
                console.log(`❌ 스레드 ${threadId}에 해당하는 GitHub 이슈를 찾을 수 없습니다. (종료 시에는 검색하지 않음)`);
                return false;
            }

            // 마지막 댓글로 종료 사유 추가
            if (reason) {
                const closeCommentBody = `**The linked forum post has been closed.**

Reason for closure: ${reason}
Closed on: ${new Date().toLocaleString('en-US')}

---
* This issue is automatically synchronized with a corresponding thread in Discord.*`;

                await axios.post(
                    `${this.baseUrl}/repos/${this.repository}/issues/${issueNumber}/comments`,
                    { body: closeCommentBody },
                    { headers: this.getHeaders() }
                );
            }

            // GitHub Issue 종료
            await axios.patch(
                `${this.baseUrl}/repos/${this.repository}/issues/${issueNumber}`,
                { state: 'closed' },
                { headers: this.getHeaders() }
            );

            // 매핑에서 제거
            this.issueMap.delete(threadId);
            
            console.log(`✅ GitHub 이슈 종료 완료: #${issueNumber}`);
            return true;

        } catch (error: any) {
            console.error('❌ GitHub 이슈 종료 중 오류:', error.response?.data || error.message);
            return false;
        }
    }

    public async handleReaction(messageId: string, threadId: string, emoji: string, userId: string, userName: string, added: boolean, threadName?: string): Promise<boolean> {
        console.log(`🔍 [GITHUB DEBUG] handleReaction 호출: emoji=${emoji}, user=${userName}, added=${added}`);
        
        if (!this.config.enabled) {
            console.log(`❌ [GITHUB DEBUG] GitHub 동기화 비활성화됨`);
            return false;
        }

        try {
            let issueNumber = this.issueMap.get(threadId);
            console.log(`🔍 [GITHUB DEBUG] 스레드 ${threadId}의 이슈 번호: ${issueNumber}`);
            
            // 메모리에 이슈 번호가 없으면 GitHub에서 검색
            if (!issueNumber && threadName) {
                console.log(`🔍 [GITHUB DEBUG] 메모리에 이슈 없음. GitHub에서 검색 시도: "${threadName}"`);
                issueNumber = await this.findExistingIssue(threadId, threadName) ?? undefined;
                
                if (issueNumber) {
                    console.log(`✅ [GITHUB DEBUG] GitHub에서 이슈 찾음: #${issueNumber}`);
                    this.issueMap.set(threadId, issueNumber);
                } else {
                    console.log(`❌ [GITHUB DEBUG] GitHub에서 이슈를 찾을 수 없음: "${threadName}"`);
                    return false;
                }
            } else if (!issueNumber) {
                console.log(`❌ [GITHUB DEBUG] 이슈 번호를 찾을 수 없음. 스레드 ID: ${threadId}, 이름: ${threadName || 'N/A'}`);
                return false;
            }

            // Discord 이모지를 GitHub 반응으로 매핑
            const githubReaction = this.mapDiscordEmojiToGitHub(emoji);
            console.log(`🔍 [GITHUB DEBUG] 이모지 매핑: ${emoji} -> ${githubReaction}`);
            
            if (!githubReaction) {
                console.log(`⚠️ [GITHUB DEBUG] 지원되지 않는 이모지: ${emoji}`);
                return false;
            }

            // 메시지 ID로 댓글 ID 확인
            const commentId = this.commentMap.get(messageId);
            let targetUrl: string;
            let targetType: string;

            console.log(`🔍 [GITHUB DEBUG] 현재 댓글 매핑 상태:`);
            console.log(`🔍 [GITHUB DEBUG] - 찾는 메시지 ID: ${messageId}`);
            console.log(`🔍 [GITHUB DEBUG] - 매핑된 댓글 ID: ${commentId || 'None'}`);
            console.log(`🔍 [GITHUB DEBUG] - 전체 댓글 매핑 수: ${this.commentMap.size}`);
            
            // 디버깅을 위해 댓글 매핑 전체 출력 (최대 5개)
            const mappingEntries = Array.from(this.commentMap.entries()).slice(0, 5);
            mappingEntries.forEach(([msgId, cmtId]) => {
                console.log(`🔍 [GITHUB DEBUG] - 매핑: ${msgId} -> ${cmtId}`);
            });

            if (commentId) {
                // 댓글에 반응 추가
                targetUrl = `${this.baseUrl}/repos/${this.repository}/issues/comments/${commentId}/reactions`;
                targetType = `댓글 #${commentId}`;
                console.log(`🎯 [GITHUB DEBUG] 댓글 반응 대상: 메시지 ${messageId} -> 댓글 ${commentId}`);
            } else {
                // 이슈에 반응 추가 (첫 번째 메시지)
                targetUrl = `${this.baseUrl}/repos/${this.repository}/issues/${issueNumber}/reactions`;
                targetType = `이슈 #${issueNumber}`;
                console.log(`🎯 [GITHUB DEBUG] 이슈 반응 대상: 첫 번째 메시지 -> 이슈 ${issueNumber}`);
                console.log(`⚠️ [GITHUB DEBUG] 댓글 매핑이 없는 이유: 첫 번째 메시지이거나 매핑이 손실됨`);
            }

            if (added) {
                // 반응 추가
                console.log(`🔍 [GITHUB DEBUG] GitHub 반응 추가 시도: ${githubReaction} to ${targetType}`);
                const addResponse = await axios.post(
                    targetUrl,
                    { content: githubReaction },
                    { 
                        headers: {
                            ...this.getHeaders(),
                            'Accept': 'application/vnd.github.squirrel-girl-preview+json'
                        }
                    }
                );
                console.log(`✅ [GITHUB DEBUG] GitHub 반응 추가 완료: ${githubReaction} to ${targetType}, 응답:`, addResponse.status);
            } else {
                // 반응 제거 - 현재 사용자의 반응을 찾아서 제거
                console.log(`🔍 [GITHUB DEBUG] GitHub 반응 제거 시도: ${githubReaction} from issue #${issueNumber}`);
                try {
                    // 이슈의 모든 반응 조회
                    const reactionsResponse = await axios.get(
                        `${this.baseUrl}/repos/${this.repository}/issues/${issueNumber}/reactions`,
                        { 
                            headers: {
                                ...this.getHeaders(),
                                'Accept': 'application/vnd.github.squirrel-girl-preview+json'
                            }
                        }
                    );

                    console.log(`🔍 [GITHUB DEBUG] 기존 반응 개수: ${reactionsResponse.data.length}`);

                    // 현재 인증된 사용자의 해당 반응 찾기
                    const currentUser = await this.getCurrentUser();
                    console.log(`🔍 [GITHUB DEBUG] 현재 사용자: ${currentUser}`);
                    
                    const userReaction = reactionsResponse.data.find((reaction: any) => 
                        reaction.content === githubReaction && reaction.user.login === currentUser
                    );

                    if (userReaction) {
                        console.log(`🔍 [GITHUB DEBUG] 제거할 반응 찾음: ID ${userReaction.id}`);
                        // 반응 제거
                        await axios.delete(
                            `${this.baseUrl}/repos/${this.repository}/issues/${issueNumber}/reactions/${userReaction.id}`,
                            { 
                                headers: {
                                    ...this.getHeaders(),
                                    'Accept': 'application/vnd.github.squirrel-girl-preview+json'
                                }
                            }
                        );
                        console.log(`✅ [GITHUB DEBUG] GitHub 반응 제거 완료: ${githubReaction}`);
                    } else {
                        console.log(`ℹ️ [GITHUB DEBUG] 제거할 반응을 찾을 수 없습니다: ${githubReaction} by ${currentUser}`);
                    }
                } catch (removeError: any) {
                    console.error('❌ [GITHUB DEBUG] GitHub 반응 제거 중 오류:', removeError.response?.data || removeError.message);
                }
            }

            console.log(`✅ [GITHUB DEBUG] handleReaction 성공적으로 완료`);
            return true;

        } catch (error: any) {
            console.error('❌ [GITHUB DEBUG] GitHub 반응 동기화 중 오류:', error.response?.data || error.message);
            return false;
        }
    }

    private mapDiscordEmojiToGitHub(discordEmoji: string): string | null {
        // Discord 이모지를 GitHub 반응으로 매핑
        const emojiMap: { [key: string]: string } = {
            // 기본 이모지들
            '👍': '+1',
            '👎': '-1',
            '😄': 'laugh',
            '🎉': 'hooray',
            '😕': 'confused',
            '❤️': 'heart',
            '🚀': 'rocket',
            '👀': 'eyes',
            
            // 다른 형태들도 지원
            '😂': 'laugh',
            '😍': 'heart',
            '🔥': 'rocket',
            '💯': 'hooray',
            '😭': 'confused',
            '👏': 'hooray',
            '✅': '+1',
            '❌': '-1',
            '💖': 'heart',
            '💜': 'heart',
            '💙': 'heart',
            '💚': 'heart',
            '💛': 'heart',
            '🧡': 'heart'
        };

        return emojiMap[discordEmoji] || null;
    }

    private async getCurrentUser(): Promise<string> {
        if (!this.currentUser) {
            try {
                const response = await axios.get(`${this.baseUrl}/user`, {
                    headers: this.getHeaders()
                });
                this.currentUser = response.data.login;
            } catch (error) {
                console.error('❌ GitHub 사용자 정보 조회 실패:', error);
                return '';
            }
        }
        return this.currentUser || '';
    }

    public async findExistingIssue(threadId: string, threadTitle: string): Promise<number | null> {
        try {
            // 1. 정확한 제목으로 검색
            let searchQuery = `repo:${this.repository} is:issue in:title "${threadTitle}"`;
            let response = await axios.get(
                `${this.baseUrl}/search/issues?q=${encodeURIComponent(searchQuery)}`,
                { headers: this.getHeaders() }
            );

            let issues = response.data.items;
            
            // 정확한 매치 찾기
            let exactMatch = issues.find((issue: any) => issue.title === threadTitle);
            if (exactMatch) {
                const issueNumber = exactMatch.number;
                this.issueMap.set(threadId, issueNumber);
                console.log(`✅ 정확한 제목으로 GitHub 이슈 찾음: #${issueNumber} - "${threadTitle}"`);
                return issueNumber;
            }

            // 2. 레이블로 검색 (discord-forum 레이블이 있는 이슈들)
            searchQuery = `repo:${this.repository} is:issue label:discord-forum`;
            response = await axios.get(
                `${this.baseUrl}/search/issues?q=${encodeURIComponent(searchQuery)}`,
                { headers: this.getHeaders() }
            );

            issues = response.data.items;
            
            // Discord 스레드 ID가 본문에 포함된 이슈 찾기
            const issueWithThreadId = issues.find((issue: any) => 
                issue.body && issue.body.includes(threadId)
            );
            
            if (issueWithThreadId) {
                const issueNumber = issueWithThreadId.number;
                this.issueMap.set(threadId, issueNumber);
                console.log(`✅ 스레드 ID로 GitHub 이슈 찾음: #${issueNumber} - "${issueWithThreadId.title}"`);
                return issueNumber;
            }

            // 3. 부분 제목 매치
            const partialMatch = issues.find((issue: any) => 
                issue.title.includes(threadTitle) || threadTitle.includes(issue.title)
            );
            
            if (partialMatch) {
                const issueNumber = partialMatch.number;
                this.issueMap.set(threadId, issueNumber);
                console.log(`✅ 부분 매치로 GitHub 이슈 찾음: #${issueNumber} - "${partialMatch.title}"`);
                return issueNumber;
            }

            console.log(`🔍 GitHub에서 "${threadTitle}" 이슈를 찾을 수 없음`);
            return null;

        } catch (error: any) {
            console.error('❌ GitHub 이슈 검색 중 오류:', error.response?.data || error.message);
            return null;
        }
    }

    public async testConnection(): Promise<boolean> {
        try {
            const response = await axios.get(
                `${this.baseUrl}/repos/${this.repository}`,
                { headers: this.getHeaders() }
            );

            console.log(`✅ GitHub 저장소 연결 성공: ${response.data.full_name}`);
            return true;

        } catch (error: any) {
            console.error('❌ GitHub 연결 실패:', error.response?.data || error.message);
            return false;
        }
    }

    public getIssueNumber(threadId: string): number | undefined {
        return this.issueMap.get(threadId);
    }

    public setIssueMapping(threadId: string, issueNumber: number): void {
        this.issueMap.set(threadId, issueNumber);
    }

    public getConfig(): GitHubConfig {
        return this.config;
    }
}